
# This program generates the application presented during our final time series analysis and forecasting presentation on 8/26.
# This application is not yet hosted on an external site, but can be regenerated by installing the required packages (please see rows 15-26)
# and then subsequently running the code from top to bottom. Please let us know if you have any difficulties rerunning the program.
# Please also note that this application is "Under development" and some areas could be improved. 
# For example, as it stands, if you select an arrival and departure combination that does not appear in the data, the program will err
# when it would ideally provide a warning message to users. We are excited to share what we have developed thus far.


######################
### Program set-up ###
######################


# clear environment
rm(list = ls())

# load shiny and other libraries
library(shiny)
library(tidyverse)
library(maps)
library(geosphere)
library(data.table)
library(forecast)
library(vars)
library(shinythemes)
library(threejs)
library(tseries)
library(fpp)
library(TSA)


# read in data
df <- readRDS("C:/Users/KMonzella/OneDrive - Mathematica/Desktop/MScA Program Work/Time Series Analysis and Forecasting/Final project/Group work/international-travel-forecasting/southeurope_input.rds")


# test parameters
# arrivals <- as.vector(unique(df$fg_apt)) tried to do this, but too many null values (routes that don't exist together)
arrivals   <- c("BCN", "CDG", "FCO", "LRH", "MAD")
departures <- c("EWR", "JFK", "LAX", "ORD", "PHL")
modeltypes <- c("Autoarima", "Naive", "Seasonal Autoarima", "TBATS")
indepvars  <- as.vector(names(df))

######################
###  ui interface  ###
######################


ui <- fluidPage(
  
  # header
  navbarPage(theme = shinytheme("flatly"), collapsible = TRUE,
             "International flights forecasting - Traveling to Southern Europe", id="nav"),
  
  tags$style(type = "text/css", "#map {height: calc(100vh - 10px) !important;}"),
  
  # Sidebar of user-defined inputs
  sidebarPanel(
    
    helpText("Choose your parameters and start modeling time series data."),
    
    # Departure and arrival cities
    selectInput(inputId = "dep",
                label   = "Departure airport",
                choices = departures),
  
    selectInput(inputId = "arr",
                label   = "Arrival airport",
                choices = arrivals),
  
    # model selection
    selectInput(inputId = "model",
                label   = "Time Series Model",
                choices = modeltypes),
    
    # conditional panels based on models
    conditionalPanel("input.model=='Seasonal Autoarima'",
                     sliderInput(inputId = 'params', 
                                 label   = "Seasonality", 
                                 min=1,
                                 max=5,
                                 1)),

    conditionalPanel("input.model=='VAR'",
                     selectInput(inputId = 'varlist', 
                                  label   = "Explanatory variables", 
                                  choices = names(df),
                                  multiple=TRUE)),
    
    # forecast horizon
    sliderInput(inputId = "num",
                label   = "Choose forecast horizon",
                value   = 2, min = 1, max=12),
  
    # submit button
    actionButton("button", "Submit")),
  
  # Main panel of outputs
  mainPanel(

    tabsetPanel(
      # plot the time series
      tabPanel("Step 1. Plot your data",             plotOutput("data"),
                                                     plotOutput('map')),
      # stationarity and lambda output
      tabPanel("Step 2. Transform your data",        helpText("Stationarity Summary: "),
                                                     textOutput('stationarity'),
                                                     helpText("KPSS summary table"),
                                                     verbatimTextOutput('kpsstable'),
                                                     helpText("ADF summary table"),
                                                     verbatimTextOutput('adftable'),
                                                     helpText("Box Cox Transformation Summary: "),
                                                     plotOutput('boxcox')),
      # residual output
      tabPanel("Step 3. Check your residuals",       helpText("Please review your residuals. Do they appear to be white noise?"),
                                                     plotOutput('residuals')),
      # plot of forecast
      tabPanel("Step 4. Forecast your data",         helpText("Check out the forecast you generated!"),
                                                     plotOutput('forecast'),
                                                     tableOutput('accuracy'))

    )
  )
)


######################
###     server     ###
######################


server <- function(input, output, session) {
  
  # create reactive objects to be used in outputs:
  
    # 1.) data, limited to airports of interest
    selectedData <- reactive({
      
        df %>% filter(usg_apt==input$dep & fg_apt==input$arr)
      
      })
  
    # 2.) time series data - limited to airports and aggregated
    selectedTSData <- reactive({
      
      t <- selectedData() %>%
        dplyr::select(c(year, month, total)) %>%
        mutate(total = as.numeric(total)) %>%
        group_by(year, month) %>%
        summarise_all(funs(sum)) %>%
        ungroup() %>%
        dplyr::select(total)
      
      t<- ts(t, frequency = 12, start=c(1990,1))
      
      return(t)
      
    })

    # this piece of code for a VAR model is under construction and not yet functional. Included for future work.
    groupvar <- reactive({input$varlist})
    
    selectedTSDataVAR <- reactive({
      
      selectedData() %>%
        dplyr::select(c(year, month, total, groupvar())) %>%
        mutate(total = as.numeric(total)) %>%
        group_by(year, month, group()) %>%
        mutate(total=sum(total, na.rm=TRUE)) %>%
        ungroup() %>%
        dplyr::select(total, groupvar())
      
    })
    
    # 3.) mapping data - limit to one observation per airport combo
    selectedMapData <- reactive({
      
      selectedData() %>%
        dplyr::select(ends_with("decimal_degrees")) %>%
        distinct()
      
    })
    
    # 4.) stationarity output
    
    kpssOutput <- reactive({
      
      kpssout <- kpss.test(selectedTSData(), null="Level")
      if (kpssout$p.value<.05) {
        kpss_text = paste("Your data are not stationary according to a KPSS test")
      }
      else if (kpssout$p.value >=.05){
        kpss_text = paste("Your data are stationary according to a KPSS test")
      }
      
      adfout <- adf.test(selectedTSData())
      if (adfout$p.value>.05) {
        adf_text = paste("your data are not stationary according to an ADF test.")
      }
      else if (adfout$p.value <.05){
        adf_text = paste("your data are stationary according to an ADF test.")
      }
      
      if (grepl("not", kpss_text) == grepl("not", adf_text)){
        transition = " and "
      }
      if (grepl("not",kpss_text) != grepl("not",adf_text)){
        transition = "; however, "
      }
      
      out = paste(kpss_text, transition, adf_text)
      
      return(out)
      
    })
    
    kpsssumm <- reactive({
      kpss.test(selectedTSData(), null="Level")
    })

    adfsumm <- reactive({
      adf.test(selectedTSData())
    })
    
    # 5.) forecast
    
    observe({
      if (input$button == 0) # tells action button to do nothing before clicked ..
        return()

      isolate({
        
      mod <- reactive({
      
      if (input$model=="Autoarima"){
        # autoarima
        mod <- auto.arima(ts(selectedTSData()))
      }
      
      if (input$model=="Seasonal Autoarima"){
        # seasonal
        mod <- auto.arima(selectedTSData(), D=input$params, seasonal = TRUE)
      }
      
      if (input$model=="Naive"){
        mod <- naive(selectedTSData())
      }
        
      if (input$model=="TBATS"){
        # fit tbats
        mod<- tbats(selectedTSData())
      }
      
        return(mod)
      
      })
      
    
      fore <- reactive({
    
        forecast(mod(), h = input$num)
    
      })
  
  # create output objects:
  
    # 1.) time series plot
    output$data <- renderPlot({
      tsdisplay(selectedTSData(), main = "Time series data plot")
    })
    
    # 2.) Stationarity output
    output$stationarity <- renderText({
      print(kpssOutput())
      
    })

    output$kpsstable <- renderPrint({
      print(kpsssumm())
      
    })

    output$adftable <- renderPrint({
      print(adfsumm())
      
    })
    
    output$boxcox <- renderPlot({
      lambda                  = BoxCox.lambda(selectedTSData())
      south_europe_ts_m_trans = BoxCox(selectedTSData(), lambda=lambda)
      tsdisplay(south_europe_ts_m_trans, main = paste("Box Cox transformation"))
    })
    
    # 3.) forecast plot
    output$forecast <- renderPlot({
    
      plot(fore(), 
           xlab = "Year", 
           ylab = "Total number of passengers")
    
    })
  
    # 3.) residual plot
    output$residuals <- renderPlot({
    
      #check residuals
      checkresiduals(mod())
    
    })
    
    # 4.) map
    
    output$map <- renderPlot({
      
      map("world", col="light gray", fill=TRUE, bg="white", lwd=0.1)
      
      # Using airports data: Add a point on the map for each airport:
      points(x=selectedMapData()$fg_longitude_decimal_degrees, 
             y=selectedMapData()$fg_latitude_decimal_degrees, 
             pch=19)
      
      points(x=selectedMapData()$usg_longitude_decimal_degrees, 
             y=selectedMapData()$usg_latitude_decimal_degrees, 
             pch=19)
      
      #  color palette for edges so that we can eventually apply a different weight
      col.1 <-adjustcolor("dark blue", alpha=0.4)
      col.2 <-adjustcolor("blue",     alpha=0.4)
      
      edge.pal <-colorRampPalette(c(col.1, col.2), alpha = TRUE)
      edge.col <- edge.pal(100)
      
      # using flights data: find the shortest path between airports
      
      arc   <- gcIntermediate(c(selectedMapData()[1,]$usg_longitude_decimal_degrees,    
                                selectedMapData()[1,]$usg_latitude_decimal_degrees),
                              c(selectedMapData()[1,]$fg_longitude_decimal_degrees, 
                               selectedMapData()[1,]$fg_latitude_decimal_degrees),
                                addStartEnd=TRUE )
        
        #edge.ind <- round(100*flights[i,]$Freq / max(flights$Freq))
        #placeholder
        edge.ind <- 50
        lines(arc, col=edge.col[edge.ind], lwd=edge.ind/10)
      
    })
   })
 })
}

# knit server and ui together
shinyApp(ui = ui, server = server)